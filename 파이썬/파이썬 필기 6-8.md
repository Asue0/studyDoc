### 6-1 구문 오류와 예외 처리

#### 구문 오류
- 문법적 실수로 인해 프로그램 실행 전에 발생하는 오류


#### 런타임 오류(예외)
- 프로그램 실행 후에 발생하는 오류 (예외 라고도 부름)

#### 예외 처리 (try except)
- try except구문으로 예외를 처리할 수 있음
  ```
  try:
      예외가 발생할 가능성이 있는 코드
  except:
      예외가 발생했을 때 실행할 코드
  ```

#### 예외 처리 2 (try except else)
- try except 구문 뒤에 else를 붙여 '예외가 발생하지 않았을 때' 실행할 코드를 지정 가능
  ```
  try:
      예외가 발생할 가능성이 있는 코드
  except:
      예외가 발생했을 때 실행할 코드
  else:
      예외가 발생하지 않았을 때 실행할 코드
  ```
- 보통 예외가 발생할 가능성이 있는 코드만 try 구문에, 나머지는 모두 else 구문으로 빼는 경우가 많음

#### 예외 처리 3 (finally)
- 예외 발생 여부와 상관없이 반드시 실행되는 코드
- 보통 파일 처리 관련에서 close() 함수를 호출 할 때 사용됨
- 주로 반드시 사용해야 한다기 보단 코드를 깔끔하게 하기 위해 사용됨
- try 구문에 return 등을 사용할 때도 finally 구문은 실행됨


---
### 6-2 예외 고급
---

#### 예외 객체란?
- 예외가 발생했을 시 발생한 예외 정보가 저장되는 객체
- 예외 정보 메세지가 저장됨

#### 예외 객체의 사용 방법
    ```
    try: 
        예외가 발생할 수 있는 구문
    except 예외의 종류 as 예외 객체를 활용할 변수 이름:
        예외가 발생했을 때 실행할 구문
    ```

#### 여러 가지 예외 사항 처리
- except 구문을 여러 개 사용해 각각 다른 예외 사항을 처리 가능
    ```
    try:
        예외 발생 가능 구문
    except 예외 종류 A:
        예외A가 발생했을 시 실행되는 구문
    except 예외 종류 B:
        예외B가 발생했을 시 실행되는 구문
    ...
    ```
- as를 붙여서 예외 객체에 예외 정보를 저장할 수도 있음
  ```
  try:
        예외 발생 가능 구문
    except 예외 종류 A as 예외 객체 :
        예외A가 발생했을 시 실행되는 구문
    except 예외 종류 B as 예외 객체 :
        예외B가 발생했을 시 실행되는 구문
    ...
  ```
  
#### 예외 처리에서의 주의 사항
- 예외 처리시 마지막 except에는 나머지 모든 예외 처리를 담당할 Exception을 넣는게 좋다.   
-> if문에서의 else처럼

#### raise 구문
- 강제로 예외를 생기게 하는 방법 
- 아직 덜 개발한 부분에 대한 처리로, pass 키워드와 비슷한 역할을 함
  ```
  raise 예외명
  ```
  ```
  raise 예외 객체
  ```

---
### 7-1 표준 모듈
---

#### 모듈이란?
- 모듈: 여러 변수와 함수를 가지고 있는 집합체
- 표준 모듈: 파이썬 기본 내장 모듈
- 외부 모듈: 다른 사람들이 만든 모듈

#### 모듈 가져오는 법
- 제일 상단에 기입
  ```
  import 모듈 명 
  ```

#### math 모듈
- 수학에 관련된 기능을 가진 표준 모듈

| 변수 또는 함수|설명|
|---|---|
| sin(x)    |사인 구하기|
| cos(x)    |코사인 구하기|
| tan(x)    |탄젠트 구하기|
| log(x[, base]) |로그값 구하기|
| ceil(x)   |올림|
|floor(x)|내림|

#### 중요) 기타 표준 모듈 종류 확인 (파이썬 공식 사이트)
  ```
  https://docs.python.org/3/library/index.html
  ```

#### from 구문
- 모듈 내에서 특정 기능(변수, 함수)만을 가져오고 싶을 때 사용
  ```
  from 모듈 이름 import 가져오고 싶은 변수명 혹은 함수명
  ```
- 모듈명.함수() 등으로 이용하던 것을 함수()만으로 호출 가능
  ```python
  from math import sin
  
  sin(1)
  ```
- ,를 써서 여러 개를 가져올 수도 있음
- 주의) 모듈 내에 같은 이름의 무언가가 존재하는 이유 등으로 충돌이 발생할 수 있음   
-> 최대한 필요한 것만 가져오기

#### as 구문
- 가져온 모듈에 알리아스(식별자)를 붙여서 사용하는 방법
  ```
  import 모듈 as 사용하고 싶은 식별자
  ```
  ```python
  import math as m
  
  m.sin(1)
  ```
 
#### 다른 표준 모듈들
- random 모듈: 랜덤한 값을 생성할 때 사용하는 표준 모듈
  ```
  import random
  ```
- sys 모듈: 시스템과 관련된 정보를 가지는 모듈
- os 모듈: 운영체제 관련 기능을 가지는 모듈
- datetime 모듈: 날짜와 시간 정보를 가지는 모듈   
-> 날짜 형식을 만들때 사용됨
- time 모듈: 시간 관련 기능을 가지는 모듈   
-> 특정 시간 동안 코드 진행을 정지 할때 많이 사용
- urllib 모듈: URL을 다루는 라이브러리

---
### 7-2 외부 모듈
---

- Flask 모듈 또한 외부 모듈임

#### 외부 모듈 설치하는 법
- CMD 창에서 다음과 같이 입력
  ```
  pip install 모듈명
  ```

#### 중요) 가상환경 설정
- 가상환경을 설정해서 파이썬 프로젝트마다 각각 다른 모듈과 버전을 설치할 수 있게함 
- 파이참 등의 툴을 이용하면 설정이 편리

#### Flask 모듈
- 웹 개발 프레임 워크
- Django와는 다르게 작은 기능만을 제공함

#### Flask 모듈 실행
- Flask로 작성한 파일은 명령창에서 다음과 같이 입력해 실행
  ```
  set FLASK_APP=파일이름.py
  flask run
  ```
- 이후 명령창에 출력되는 주소로 들어가면 확인 가능

#### 라이브러리와 프레임워크의 차이
|구분|설명|
|---|---|
|라이브러리(library)|정상적인 제어를 하는 모듈|
|프레임워크(framework)|제어 역전이 발생하는 모듈|

- 라이브러리: 개발자가 모듈의 기능을 호출하는 형태의 모듈
- 프레임워크: 모듈이 개발자가 작성한 코드를 실행하는 형태의 모듈
- 제어의 역전: 개발자가 만든 함수를 모듈이 실행하는 것

#### 함수 데코레이터
- 파이썬에서 @로 시작하는 구문을 데코레이터라 함
- 함수에 사용하는 데코레이터를 함수 데코레이터라 함
  ```
  def 함수1(function):
    def wrapper():
      ...  
    return wrapper
  
  @함수1
  def 함수2():
    ...
  
  함수2()
  ```
- 함수2를 호출하면 함수1을 호출해 함수2를 매개변수로 넣어준다.
- (주의) 어노테이션과 비슷하지만 기능은 크게 다르므로 주의

---
### 7-3 모듈 생성
---

#### 모듈 생성 방법
- 기본적으로 파이썬 파일을 만들고 이를 다른 곳에서 불러 읽으면 그게 모듈임
- 모듈을 구조화 해서 거대한 모듈(패키지)를 만들 수도 있음
- 모듈 내부에 변수와 함수를 넣으면 모듈 완성

#### 네임
- \_\_name\_\_ : 코드 실행 위치를 출력함
- 프로그램 진입점(엔트리 포인트, 메인)에선 \_\_main\_\_을 출력함
- 모듈 내에선 모듈의 이름을 출력함
- 따라서 현재 파일이 모듈로 실행되는지 엔트리 포인트로 실행되는지 확인 가능
- 즉) 엔트리 포인트일 때만 실행되는 구절을 만들고 싶을 때 네임 코드를 사용

#### 패키지
- 패키지: 여러 모듈들이 모여서 구조를 이루는 형태
- 쉽게 말해 관련 모듈을 모아놓은 폴더를 말함
  ```
  import 패키지(폴더명).모듈명
  ```

#### 이닛 파일
- \_\_init\_\_.py 
- 패키지를 읽을 때 가장 먼저 읽어들임
- 패키지 호출 시 반드시 실행하고 싶은 처리가 있을 경우에 생성해 사용
- 패키지 폴더 내부에 생성함


---
### 8-1 클래스의 기본
---

#### 클래스의 정의
- 객체: 여러 가지 속성을 가질 수 있는 대상
- 클래스: 객체를 효율적으로 생성하기 위해 만들어진 구문

#### 클래스 선언
```
class 클래스 이름:
  클래스 내용
```
- 클래스의 첫글자는 대문자로 작성

#### 클래스 호출
```
인스턴스 이름(변수 이름) = 클래스명()
```

#### 생성자
- 자바에서의 생성자와 동일
- 파이썬에선 생성자의 이름을 \_\_init\_\_으로 생성하고   
첫번째 매개변수를 반드시 self로 해야함
  ```
  class 클래스 이름:
    def __init__(self, 추가적인 매개변수...):
      ...
  ```
- 이때 self란 자기 자신을 나타내는 딕셔너리
  ```python
  class A:
    def __init__(self, 매개변수1, 매개변수2):
        self.매개변수1 = 매개변수1
        self.매개변수2 = 매개변수2
  
  b = A(1, 2)
  
  print(b.매개변수1)
  print(b.매개변수2)
  ```
  ```
  1
  2
  ```
- self는 키워드가 아니라 직접 작명 가능한 식별자
- 하지만 self로 사용하는게 암묵적인 룰

#### 소멸자
- 생성자와는 반대로 인스턴스가 소멸될 때 호출되는 함수
- 많이 사용하는 기능은 아님
  ```
  # 클래스 내부에서
  def __del__(self):
    인스턴스 소멸시 호출될 코드
  ```

#### 메소드
- 클래스가 가지고 있는 함수를 메소드라 부름
- 메소드 또한 첫 매개변수로 self를 반드시 넣어야함
  ```python
  class 클래스명:
    def 메소드 명(self, 매개변수):
        ...
  ```

---
### 8-2 클래스의 추가적인 구문
---

#### 어떤 클래스의 인스턴스인지 확인
- isinstance(a, b) 함수: a 객체(인스턴스)가 b 클래스로부터 만들어졌는지 확인 
  ```
  isinstance(인스턴스명, 클래스명)
  ```
- 맞다면 True, 틀리다면 False를 리턴
- 주의) type() 함수를 사용하면 바로 인스턴스의 클래스명을 알 수 있지만,  
'상속'을 사용할 경우 다르게 동작하므로 주의
  ```
  isinstance() 함수: 상속된 클래스를 사용한 객체와 부모 클래스를 매칭하면 True를 리턴
  type() 함수: 자식 클래스로만 출력됨
  ```

#### 클래스를 보조해주는 메소드
- \_\_이름\_\_의 형태로 되어 있는 메소드들은 특수한 상황에 자동으로 호출됨
- 각 기능들은 툴이나 검색을 통해 참조

#### 클래스 변수
- 자바와 동일
- 필드에 변수 = 값으로 선언
- 부정확한 내용) 파이썬은 생성자에 넣은 값이 딕셔너리 형태로 저장되니 따로 쓸 일은 거의 없을듯?
  ```
  # 접근하는 법
  클래스 명.변수 이름
  ```

#### 클래스 메소드
- 일반 메소드랑 큰 차이는 없으나 '클래스가 가진 기능'이라고 명시적으로 나타냄
- 클래스, 혹은 인스턴스에 저장해둔 정보를 토대로 기능하게 만든 메소드
- @classmethod를 붙여줘서 사용 (@부분을 데코레이터라 함)
  ```
  class 클래스 명:
    @classmethod
    def 클래스 함수(cls, 매개변수):
      ...
  ```
- 클래스 메소드의 첫 매개변수는 그 클래스 자체가 들어옴
- 통념적으로 cls라는 이름으로 표기
  ```
  # 클래스 메소드 호출 방법
  클래스명.클래스 메소드명(매개변수)
  ```
  
#### 프라이빗 변수
- 클래스 내부의 변수를 외부에서 사용하는 것을 막고 싶을 때 사용
- \_\_변수 이름의 형태로 선언함
- 클래스 외부에서 클래스명.\_\_프라이빗변수의 형태로 접근이 불가능

#### 겟터 섹터
- 자바의 겟터 섹터와 기능적으로 동일
- 겟터, 섹터 함수를 제작해 프라이빗 변수에 접근이 가능하게 함
- 겟터 섹터는 데코레이터를 지원 (적극 사용을 권장)
   ```
  # 겟터
  @property
  def 프라이빗변수명(self):
    return self.__프라이빗변수명
  
  # 섹터
  @프라이빗변수명.setter
  def 프라이빗변수명(self, 매개변수):
    self.__프라이빗변수명 = 매개변수
  ```
- 겟터 섹터 제작시 일반 클래스 변수처럼 접근 가능 (파이썬에서 자동으로 겟터 섹터 호출)
  ```
  클래스명.프라이빗변수명
  ```
  
#### 상속
- 자바의 상속과 동일
- 기존의 틀을 가져와 일부만 교체하는 개념

#### 상속 선언
- 클래스 생성시 상속을 선언 가능
- class 자식클래스명(부모클래스명):
```
class A:
  ...
  
class B(A):
  ...
```
- 상속시 자식 클래스에서 부모 클래스가 가지는 함수 변수 모두 활용 가능

#### 오버라이드
- 자바의 오버라이드와 동일
- 부모 클래스의 메소드를 자식 클래스에서 다시 선언해 내용을 바꾸는 것을 말함
