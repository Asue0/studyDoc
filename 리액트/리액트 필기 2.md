
---
### Component
---

#### 컴포넌트의 정의
- 원하는 html 내용들을 깔끔하게 축약해줌
- 함수 안에 html 내용을 넣어서 함수를 불러와 뿌려주는 형식
    ```
    1. function App() 바깥 영역에서 함수 선언
    2. 생성한 함수 안에서 return()을 선언하고 그 안에 html을 담음
    3. function App()의 return() 영역으로 돌아와 <생성한 함수명></생성한 함수명>으로 호출
    ```
- 주의) 컴포넌트 생성시 return()영역 최상위에 같은 태그 존재 안하도록 주의
- 참고) </컴포넌트명>으로만 사용해도 됨
- 참고2) function App()또한 컴포넌트임

#### 컴포넌트를 활용하면 좋은 경우
- 반복적인 html을 축약할 때
- 큰 페이지
- 자주 변경하게 되는 것들

#### 컴포넌트의 단점
- 외부에서 호출시 state 활용이 어려움


---
### 동적 UI 만들기
---

#### 동적 UI 만드는 순서
- 1. HTML CSS로 미리 디자인 완성 (컴포넌트로)
- 2. UI 현재 상태(창을 띄울건지 말건지 등)를 state로 저장
- 3. state에 따라 UI가 어떻게 보일지 조건문 등으로 작성
    ```
    # 스테이트 선언부
    let [a, b] = ustState(현재 상태)  # 스위치 역할
    ```
    ```
    # 조건부
    {
        a == true ? <컴포넌트명/> : null
    }
    ```
- return() 안에서 원하는 위치에 { }를 적고 안에 조건부 사용
- 주의) if문은 사용 불가능 -> 삼항 연산자 사용

#### js와 리액트의 차이점
- js: 버튼 클릭시 UI의 html을 직접 건드림
- 리액트:  UI의 스위치(state)만 건드림   
-> 차이점에 유념해서 리액트를 배워야함

---
### map 함수
---

#### js에서의 map 함수 사용법
- 형태
    ```
    array자료형.map(콜백 함수)
    ```
- array의 요소 갯수만큼 콜백 함수를 반복해서 실행함
- 콜백 함수 안에 파라미터 값은 array의 요소 값이 됨
    ```
    [1, 2, 3].map(function(a){
        console.log(a)
    })
    ```
    ```
    1
    2
    3
    ```
- return을 붙이면 요소의 값을 다시 array의 값으로 담아줌
    ```
    [1, 2, 3].map(function(a){
        return 'a'
    })
    ```
    ```
    [a, a, a]
    ```
- 콜백 함수에 파라미터 값을 두 개 줄 수 있음
    ```
    [1, 2, 3].map(function(a, i){
        return 'a'
    })
    ```
- 이 경우 i는 반복할 때마다 0부터 1씩 증가하는 값이 됨

#### 리액트에서 map 함수 활용
- 리액트에서 조건문은 삼항연산자를 이용
- 리액트에서 반복문은 map 함수를 이용
    ```JSX
    [1, 2, 3].map(function() {
        return (<div>안녕</div>)
    })
    ```
    ```
    안녕
    안녕
    안녕
    ```
- 원리: 리액트는 array 안에 html코드를 담아놔도 알아서 해체해서 잘 보여줌

#### map 함수 사용시 주의
- 각 반복된 html 태그는 유니크한 key 값을 가져야함
- 때문에 콜백 함수의 두번 째 파라미터를 이용해서 고유 값을 생성해주면 됨
    ```
    리스트.map(function(a, i){
        return (
            <div className="이름" key={i}>
            ... 중락 ...
        )
    })
    ```

---
### props 문법
---

#### props의 정의
- 리액트에서 부모 컴포넌트에 있는 스테이트 변수를 자식 컴포넌트에서 사용하는 방법
    ```
    function App() {

        스테이트 변수 J

        return (
            B를 호출해서 사용할 때 props를 이용해 J를 사용할 수 있음
        )

        function B() {
            
        }
    }
    ```

#### props 사용법
- 1. 부모 컴포넌트에서 자식 컴포넌트 호출시 state 변수 전송
    ```
    {
        <자식컴포넌트명 이름1={state이름}/>
    }
    // 보통 이름1과 state이름은 같게 하는게 규칙
    ```
- 2. 자식 컴포넌트의 매개변수를 적어줌
    ```
    function 자식컴포넌트(props)
    // 매개변수 이름은 props로 하는게 규칙
    ```
- 3. 자식 컴포넌트 안에서 매개변수.이름1로 호출
    ```
    function 자식컴포넌트(props) {
       return (
            <h1>props.이름1</h1>
       ) 
    }
    ```
- state 변수값이 리스트일 경우 이름1[index]로 쓰면 된다.

#### props 주의사항
- 부모 컴포넌트 -> 자식 컴포넌트로만 가능 (반대는 불가)
- 중요) 그렇기에 state 변수는 그 state를 사용하는 최상위 컴포넌트에 만들어야함
#### props 응용
- props는 변수만이 아니라 함수, 문자열 등 다양한 것을 전송 가능

---
### input 태그 활용 
--- 

#### onChange
- input 태그에 활용 가능한 이벤트 핸들러
- 유저가 태그에 타이핑 할 때마다 이벤트 발생
    ```
    <input onChange={ () => { 내용 } } />
    ```

#### onClick
- input 태그에 활용 가능한 이벤트 핸들러
- 유저가 태그를 클릭할 때마다 이벤트 발생

#### 그 이외의 이벤트 핸들러
- 그 이외에도 이벤트 핸들러는 다양 
- 외울 필요 x
- 필요할 때마다 인터넷 검색해서 확인

#### 이벤트 객체
- 이벤트 핸들러 함수 안에 적는 매개변수를 말함
    ```Jsx
    <input onChange={ (e) => { 코드 } } />
    // 보통 e라고 작명함
    ```
- 이벤트 객체 안에는 다양한 기능이 있음
    ```
    e.target : 현재 이벤트가 발생하는 태그
    e.target.value : 현재 이벤트가 발생한 태그의 값
    ```
#### 참고) 이벤트 버블링 (js 문법)
- 이벤트 동작을 원하는 하위 태그에서만 하는 방법
    ```
    <태그1>
        <태그2 onClick={ ()=>{이벤트} }><태그2>
    </태그1>
    // 이 경우 태그1을 클릭해도 태그2의 클릭 이벤트가 발생하는 문제 발생
    ```
- 이벤트 버블링 사용법 (이벤트 객체의 stopPropagation 함수 사용)
    ```
    <태그1>
        <태그2 onClick={ (e)=>{ e.stopPropagation(); 이벤트 코드 } }><태그2>
    </태그1>
    // 이 경우 태그1을 클릭해도 태그2의 클릭 이벤트가 발생하는 문제 발생
    ```

